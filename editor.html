<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        .page-container { position: relative; }
        .overlay-canvas { position: absolute; left: 0; top: 0; pointer-events: none; }
        .tool-btn-active { background-color: #2563EB; color: white; }
        .handle { position: absolute; width: 8px; height: 8px; background: #2563EB; border-radius: 9999px; border: 2px solid white; box-shadow: 0 0 0 1px #2563EB; }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="max-w-7xl mx-auto p-4">
        <div class="flex items-center justify-between mb-4">
            <div class="flex items-center gap-2">
                <a href="index.html" class="text-sm px-3 py-1 rounded border border-gray-300 hover:bg-gray-50">Back</a>
                <h1 class="text-2xl font-bold text-gray-800">PDF Editor</h1>
            </div>
            <div class="flex items-center gap-2">
                <input id="file-input" type="file" accept="application/pdf" class="hidden" aria-label="Open PDF file">
                <button id="btn-open" class="px-3 py-2 border rounded bg-white hover:bg-gray-50">Open PDF</button>
                <button id="btn-download" class="px-3 py-2 border rounded bg-blue-600 text-white hover:bg-blue-700" disabled>Download Edited PDF</button>
                <button id="btn-split" class="px-3 py-2 border rounded bg-white hover:bg-gray-50" title="Split current PDF">Split</button>
                <input id="merge-input" type="file" accept="application/pdf" class="hidden" multiple aria-label="Select PDFs to merge">
                <button id="btn-merge" class="px-3 py-2 border rounded bg-white hover:bg-gray-50" title="Merge PDFs">Merge</button>
            </div>
        </div>

        <div class="flex gap-4">
            <div class="w-64 bg-white border rounded p-3 h-fit sticky top-4">
                <div class="font-semibold text-gray-700 mb-2">Tools</div>
                <div class="grid grid-cols-2 gap-2 mb-3">
                    <button data-tool="select" class="tool-btn px-2 py-1 border rounded tool-btn-active">Select</button>
                    <button data-tool="draw" class="tool-btn px-2 py-1 border rounded">Draw</button>
                    <button data-tool="text" class="tool-btn px-2 py-1 border rounded">Text</button>
                    <button data-tool="image" class="tool-btn px-2 py-1 border rounded">Image</button>
                    <button data-tool="rect" class="tool-btn px-2 py-1 border rounded">Rect</button>
                    <button data-tool="ellipse" class="tool-btn px-2 py-1 border rounded">Ellipse</button>
                    <button data-tool="arrow" class="tool-btn px-2 py-1 border rounded">Arrow</button>
                    <button data-tool="highlight" class="tool-btn px-2 py-1 border rounded">Highlighter</button>
                </div>
                <div class="font-semibold text-gray-700 mb-2">Options</div>
                <div class="space-y-2">
                    <label class="text-sm flex items-center justify-between">
                        <span>Stroke width</span>
                        <input id="stroke-width" type="range" min="1" max="12" value="3">
                    </label>
                    <label class="text-sm flex items-center justify-between">
                        <span>Color</span>
                        <input id="color" type="color" value="#1f2937">
                    </label>
                    <label class="text-sm flex items-center justify-between">
                        <span>Opacity</span>
                        <input id="opacity" type="range" min="0.1" max="1" step="0.05" value="1">
                    </label>
                    <label class="text-sm flex items-center justify-between">
                        <span>Text size</span>
                        <input id="text-size" type="number" class="w-20 border rounded px-2 py-1" value="16" min="8" max="96">
                    </label>
                    <div class="grid grid-cols-3 gap-2 pt-2">
                        <button id="btn-undo" class="w-full px-2 py-1 border rounded disabled:opacity-50 flex items-center justify-center whitespace-nowrap text-center" disabled>Undo</button>
                        <button id="btn-redo" class="w-full px-2 py-1 border rounded disabled:opacity-50 flex items-center justify-center whitespace-nowrap text-center" disabled>Redo</button>
                        <button id="btn-forward" class="w-full px-2 py-1 border rounded flex items-center justify-center whitespace-nowrap text-center" title="Bring forward">Bring ↑</button>
                        <button id="btn-backward" class="w-full px-2 py-1 border rounded flex items-center justify-center whitespace-nowrap text-center" title="Send backward">Send ↓</button>
                        <button id="btn-clear" class="w-full px-2 py-1 border rounded flex items-center justify-center whitespace-nowrap text-center">Clear page</button>
                    </div>
                </div>
            </div>

            <div id="viewer" class="flex-1 space-y-6 overflow-auto" style="max-height: calc(100vh - 96px);"></div>
        </div>
    </div>

    <input id="hidden-image-input" type="file" accept="image/*" class="hidden" aria-label="Select image to insert">

    <script>
        const { PDFDocument, rgb, degrees } = PDFLib;
        // PDF.js worker
        if (window['pdfjsLib']) {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }

        const fileInput = document.getElementById('file-input');
        const btnOpen = document.getElementById('btn-open');
        const btnDownload = document.getElementById('btn-download');
        const btnSplit = document.getElementById('btn-split');
        const btnMerge = document.getElementById('btn-merge');
        const mergeInput = document.getElementById('merge-input');
        const viewer = document.getElementById('viewer');
        const hiddenImageInput = document.getElementById('hidden-image-input');

        const toolButtons = Array.from(document.querySelectorAll('.tool-btn'));
        let currentTool = 'select';

        let pdfBytesOriginal = null; // persistent Uint8Array of the opened PDF
        let pdfProxy = null;
        let pageStates = []; // per page: items and drawings
        let selection = null; // {pageIndex, id}
        let historyStack = [];
        let redoStack = [];

        const DEFAULTS = {
            strokeWidth: 3,
            color: '#1f2937',
            textSize: 16,
            opacity: 1
        };

        const strokeWidthInput = document.getElementById('stroke-width');
        const colorInput = document.getElementById('color');
        const textSizeInput = document.getElementById('text-size');
        const opacityInput = document.getElementById('opacity');
        const btnUndo = document.getElementById('btn-undo');
        const btnRedo = document.getElementById('btn-redo');
        const btnClear = document.getElementById('btn-clear');
        const btnForward = document.getElementById('btn-forward');
        const btnBackward = document.getElementById('btn-backward');

        function setTool(tool) {
            currentTool = tool;
            toolButtons.forEach(b => b.classList.toggle('tool-btn-active', b.dataset.tool === tool));
            // enable pointer events on overlay when drawing/placing
            document.querySelectorAll('.overlay-canvas').forEach(c => {
                c.style.pointerEvents = (tool === 'draw' || tool === 'text' || tool === 'image' || tool === 'select') ? 'auto' : 'none';
            });
        }

        toolButtons.forEach(btn => btn.addEventListener('click', () => setTool(btn.dataset.tool)));

        btnOpen.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const buf = await file.arrayBuffer();
            pdfBytesOriginal = new Uint8Array(buf);
            // Pass a copy to the PDF.js worker to prevent detaching our original bytes
            await loadPdfFromArrayBuffer(pdfBytesOriginal.slice().buffer);
            btnDownload.disabled = false;
        });

        // Split current PDF
        btnSplit.addEventListener('click', async () => {
            if (!pdfBytesOriginal) return alert('Open a PDF first.');
            const range = prompt('Enter page range to split (e.g., 1-3,5)');
            if (!range) return;
            try {
                const pagesToExtract = parseRange(range, pdfProxy ? pdfProxy.numPages : 1000);
                const srcDoc = await PDFDocument.load(pdfBytesOriginal);
                const newDoc = await PDFDocument.create();
                const copied = await newDoc.copyPages(srcDoc, pagesToExtract.map(n => n - 1));
                copied.forEach(p => newDoc.addPage(p));
                const bytes = await newDoc.save();
                downloadBlob(bytes, 'split.pdf');
            } catch (err) {
                console.error(err);
                alert('Invalid range or split failed.');
            }
        });

        // Merge PDFs
        btnMerge.addEventListener('click', () => mergeInput.click());
        mergeInput.addEventListener('change', async (e) => {
            const files = Array.from(e.target.files || []);
            if (files.length === 0) return;
            try {
                const out = await PDFDocument.create();
                for (const f of files) {
                    const ab = await f.arrayBuffer();
                    const src = await PDFDocument.load(ab);
                    const copied = await out.copyPages(src, src.getPageIndices());
                    copied.forEach(p => out.addPage(p));
                }
                const bytes = await out.save();
                downloadBlob(bytes, 'merged.pdf');
            } catch (err) {
                console.error(err);
                alert('Merge failed.');
            } finally {
                mergeInput.value = '';
            }
        });

        async function loadPdfFromArrayBuffer(buf) {
            viewer.innerHTML = '';
            pageStates = [];
            historyStack = []; redoStack = [];
            const loadingTask = pdfjsLib.getDocument({ data: buf });
            pdfProxy = await loadingTask.promise;
            const total = pdfProxy.numPages;
            for (let i = 1; i <= total; i++) {
                const page = await pdfProxy.getPage(i);
                const viewport = page.getViewport({ scale: 1.25 });

                const container = document.createElement('div');
                container.className = 'page-container bg-white shadow rounded overflow-hidden mx-auto w-fit';
                container.style.position = 'relative';

                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = viewport.width;
                canvas.height = viewport.height;
                container.appendChild(canvas);

                const overlay = document.createElement('canvas');
                overlay.width = viewport.width;
                overlay.height = viewport.height;
                overlay.className = 'overlay-canvas';
                overlay.style.width = canvas.style.width;
                overlay.style.height = canvas.style.height;
                container.appendChild(overlay);

                const textLayer = document.createElement('div');
                textLayer.style.position = 'absolute';
                textLayer.style.left = '0';
                textLayer.style.top = '0';
                textLayer.style.width = viewport.width + 'px';
                textLayer.style.height = viewport.height + 'px';
                textLayer.style.pointerEvents = 'none';
                container.appendChild(textLayer);

                viewer.appendChild(container);

                const renderTask = page.render({ canvasContext: ctx, viewport });
                await renderTask.promise;

                pageStates.push({
                    width: viewport.width,
                    height: viewport.height,
                    items: [], // positioned elements: {id,type,x,y,w,h,data}
                    paths: []  // freehand: array of points arrays with style
                });

                attachPageInteractions(i - 1, overlay, textLayer);
            }
        }

        function pushHistory(action) {
            historyStack.push(action);
            redoStack = [];
            btnUndo.disabled = historyStack.length === 0;
            btnRedo.disabled = redoStack.length === 0;
        }

        btnUndo.addEventListener('click', () => {
            const act = historyStack.pop();
            if (!act) return;
            redoStack.push(act);
            if (act.type === 'add-item') {
                const ps = pageStates[act.pageIndex];
                ps.items = ps.items.filter(it => it.id !== act.item.id);
                redrawPage(act.pageIndex);
            } else if (act.type === 'add-path') {
                const ps = pageStates[act.pageIndex];
                ps.paths.pop();
                redrawPage(act.pageIndex);
            } else if (act.type === 'move-item') {
                const it = pageStates[act.pageIndex].items.find(i => i.id === act.itemId);
                if (it) { it.x = act.prev.x; it.y = act.prev.y; redrawPage(act.pageIndex); }
            } else if (act.type === 'resize-item') {
                const it = pageStates[act.pageIndex].items.find(i => i.id === act.itemId);
                if (it) { it.w = act.prev.w; it.h = act.prev.h; redrawPage(act.pageIndex); }
            } else if (act.type === 'clear-page') {
                pageStates[act.pageIndex] = act.prev;
                redrawPage(act.pageIndex);
            }
            btnUndo.disabled = historyStack.length === 0;
            btnRedo.disabled = redoStack.length === 0 ? true : false;
        });

        btnRedo.addEventListener('click', () => {
            const act = redoStack.pop();
            if (!act) return;
            if (act.type === 'add-item') {
                pageStates[act.pageIndex].items.push(act.item);
                redrawPage(act.pageIndex);
            } else if (act.type === 'add-path') {
                pageStates[act.pageIndex].paths.push(act.path);
                redrawPage(act.pageIndex);
            } else if (act.type === 'move-item') {
                const it = pageStates[act.pageIndex].items.find(i => i.id === act.itemId);
                if (it) { it.x = act.next.x; it.y = act.next.y; redrawPage(act.pageIndex); }
            } else if (act.type === 'resize-item') {
                const it = pageStates[act.pageIndex].items.find(i => i.id === act.itemId);
                if (it) { it.w = act.next.w; it.h = act.next.h; redrawPage(act.pageIndex); }
            } else if (act.type === 'clear-page') {
                pageStates[act.pageIndex] = { width: act.prev.width, height: act.prev.height, items: [], paths: [] };
                redrawPage(act.pageIndex);
            }
            historyStack.push(act);
            btnUndo.disabled = historyStack.length === 0 ? true : false;
            btnRedo.disabled = redoStack.length === 0;
        });

        btnClear.addEventListener('click', () => {
            const containerIndex = getCurrentViewportTopPageIndex();
            if (containerIndex == null) return;
            const prev = JSON.parse(JSON.stringify(pageStates[containerIndex]));
            pageStates[containerIndex].items = [];
            pageStates[containerIndex].paths = [];
            redrawPage(containerIndex);
            pushHistory({ type: 'clear-page', pageIndex: containerIndex, prev });
        });

        function getCurrentViewportTopPageIndex() {
            const containers = Array.from(viewer.querySelectorAll('.page-container'));
            const viewportTop = viewer.scrollTop;
            let bestIndex = 0;
            let bestDist = Infinity;
            containers.forEach((c, i) => {
                const d = Math.abs(c.offsetTop - viewportTop);
                if (d < bestDist) { bestDist = d; bestIndex = i; }
            });
            return bestIndex;
        }

        function attachPageInteractions(pageIndex, overlay, textLayer) {
            const ctx = overlay.getContext('2d');
            let drawing = false;
            let currentPath = null;
            let dragItem = null; // reference to item being moved
            let dragOffset = { x: 0, y: 0 };
            let resizing = null; // {itemId, corner}

            function toLocal(e) {
                const rect = overlay.getBoundingClientRect();
                return { x: e.clientX - rect.left, y: e.clientY - rect.top };
            }

            overlay.addEventListener('mousedown', (e) => {
                const p = toLocal(e);
                if (currentTool === 'draw') {
                    drawing = true;
                    currentPath = { points: [p], color: colorInput.value, width: parseInt(strokeWidthInput.value, 10), opacity: parseFloat(opacityInput.value) };
                } else if (currentTool === 'text') {
                    const text = prompt('Enter text');
                    if (text) {
                        const item = { id: crypto.randomUUID(), type: 'text', x: p.x, y: p.y, w: text.length * parseInt(textSizeInput.value, 10) * 0.6, h: parseInt(textSizeInput.value, 10) * 1.2, data: { text, size: parseInt(textSizeInput.value, 10), color: colorInput.value, opacity: parseFloat(opacityInput.value) } };
                        pageStates[pageIndex].items.push(item);
                        pushHistory({ type: 'add-item', pageIndex, item });
                        redrawPage(pageIndex);
                    }
                } else if (currentTool === 'image') {
                    hiddenImageInput.onchange = async (ev) => {
                        const file = ev.target.files[0];
                        if (!file) return;
                        const url = URL.createObjectURL(file);
                        const img = new Image();
                        img.onload = () => {
                            const maxW = 200;
                            const scale = Math.min(1, maxW / img.width);
                            const w = img.width * scale;
                            const h = img.height * scale;
                            const item = { id: crypto.randomUUID(), type: 'image', x: p.x, y: p.y, w, h, data: { url, opacity: parseFloat(opacityInput.value) } };
                            pageStates[pageIndex].items.push(item);
                            pushHistory({ type: 'add-item', pageIndex, item });
                            redrawPage(pageIndex);
                            URL.revokeObjectURL(url);
                        };
                        img.src = url;
                        hiddenImageInput.value = '';
                    };
                    hiddenImageInput.click();
                } else if (currentTool === 'rect' || currentTool === 'ellipse' || currentTool === 'arrow' || currentTool === 'highlight') {
                    drawing = true;
                    currentPath = { kind: currentTool, start: p, end: p, color: colorInput.value, width: parseInt(strokeWidthInput.value, 10), opacity: parseFloat(opacityInput.value) };
                } else if (currentTool === 'select') {
                    const hit = hitTestItem(pageIndex, p);
                    if (hit) {
                        selection = { pageIndex, id: hit.id };
                        if (hit.corner) {
                            resizing = { itemId: hit.id, corner: hit.corner };
                        } else {
                            dragItem = hit;
                            dragOffset = { x: p.x - hit.x, y: p.y - hit.y };
                        }
                        redrawPage(pageIndex);
                    } else {
                        selection = null;
                        redrawPage(pageIndex);
                    }
                }
            });

            overlay.addEventListener('mousemove', (e) => {
                const p = toLocal(e);
                if (currentTool === 'draw' && drawing) {
                    currentPath.points.push(p);
                    redrawPage(pageIndex, ctx, currentPath);
                } else if (drawing && currentPath && (currentTool === 'rect' || currentTool === 'ellipse' || currentTool === 'arrow' || currentTool === 'highlight')) {
                    currentPath.end = p;
                    redrawPage(pageIndex, ctx, null, currentPath);
                } else if (dragItem) {
                    const it = pageStates[pageIndex].items.find(i => i.id === dragItem.id);
                    if (it) {
                        const prev = { x: it.x, y: it.y };
                        it.x = p.x - dragOffset.x; it.y = p.y - dragOffset.y;
                        redrawPage(pageIndex);
                        // update last move action or push new
                    }
                } else if (resizing) {
                    const it = pageStates[pageIndex].items.find(i => i.id === resizing.itemId);
                    if (it) {
                        const prev = { w: it.w, h: it.h };
                        const dx = p.x - it.x; const dy = p.y - it.y;
                        it.w = Math.max(10, dx); it.h = Math.max(10, dy);
                        redrawPage(pageIndex);
                    }
                }
            });

            overlay.addEventListener('mouseup', (e) => {
                if (currentTool === 'draw' && drawing) {
                    drawing = false;
                    pageStates[pageIndex].paths.push(currentPath);
                    pushHistory({ type: 'add-path', pageIndex, path: currentPath });
                    currentPath = null;
                    redrawPage(pageIndex);
                } else if (drawing && currentPath && (currentTool === 'rect' || currentTool === 'ellipse' || currentTool === 'arrow' || currentTool === 'highlight')) {
                    drawing = false;
                    // convert shape to an item for z-ordering and selection
                    const item = shapePathToItem(currentPath);
                    pageStates[pageIndex].items.push(item);
                    pushHistory({ type: 'add-item', pageIndex, item });
                    currentPath = null;
                    redrawPage(pageIndex);
                } else if (dragItem) {
                    const it = pageStates[pageIndex].items.find(i => i.id === dragItem.id);
                    if (it) {
                        pushHistory({ type: 'move-item', pageIndex, itemId: it.id, prev: { x: dragItem.x, y: dragItem.y }, next: { x: it.x, y: it.y } });
                    }
                    dragItem = null;
                } else if (resizing) {
                    const it = pageStates[pageIndex].items.find(i => i.id === resizing.itemId);
                    if (it) {
                        pushHistory({ type: 'resize-item', pageIndex, itemId: it.id, prev: { w: dragItem ? dragItem.w : it.w, h: dragItem ? dragItem.h : it.h }, next: { w: it.w, h: it.h } });
                    }
                    resizing = null;
                }
            });

            function redrawPage(idx, tempCtx = null, tempPath = null, tempShape = null) {
                const overlay = viewer.querySelectorAll('.overlay-canvas')[idx];
                const ctx = overlay.getContext('2d');
                ctx.clearRect(0, 0, overlay.width, overlay.height);

                // draw paths
                for (const path of pageStates[idx].paths) {
                    ctx.save();
                    ctx.globalAlpha = path.opacity ?? 1;
                    ctx.strokeStyle = path.color; ctx.lineWidth = path.width; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                    ctx.beginPath();
                    for (let i = 0; i < path.points.length; i++) {
                        const pt = path.points[i];
                        if (i === 0) ctx.moveTo(pt.x, pt.y); else ctx.lineTo(pt.x, pt.y);
                    }
                    ctx.stroke();
                    ctx.restore();
                }

                // temp drawing
                if (tempPath) {
                    ctx.save();
                    ctx.globalAlpha = tempPath.opacity ?? 1;
                    ctx.strokeStyle = tempPath.color; ctx.lineWidth = tempPath.width; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
                    ctx.beginPath();
                    for (let i = 0; i < tempPath.points.length; i++) {
                        const pt = tempPath.points[i];
                        if (i === 0) ctx.moveTo(pt.x, pt.y); else ctx.lineTo(pt.x, pt.y);
                    }
                    ctx.stroke();
                    ctx.restore();
                }

                // temp shape preview
                if (tempShape) {
                    ctx.save();
                    ctx.globalAlpha = tempShape.opacity ?? 1;
                    drawShape(ctx, tempShape);
                    ctx.restore();
                }

                // draw items
                const items = pageStates[idx].items;
                items.forEach(it => {
                    if (it.type === 'text') {
                        ctx.save();
                        ctx.globalAlpha = it.data.opacity ?? 1;
                        ctx.fillStyle = it.data.color;
                        ctx.font = `${it.data.size}px Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
                        ctx.textBaseline = 'top';
                        ctx.fillText(it.data.text, it.x, it.y);
                        ctx.restore();
                    } else if (it.type === 'image') {
                        const img = new Image();
                        img.onload = () => {
                            ctx.save();
                            ctx.globalAlpha = it.data.opacity ?? 1;
                            ctx.drawImage(img, it.x, it.y, it.w, it.h);
                            ctx.restore();
                        };
                        img.src = it.data.url;
                    } else if (it.type === 'rect' || it.type === 'ellipse' || it.type === 'arrow' || it.type === 'highlight') {
                        ctx.save();
                        ctx.globalAlpha = it.data.opacity ?? 1;
                        drawShape(ctx, { kind: it.type === 'highlight' ? 'rect' : it.type, start: { x: it.x, y: it.y }, end: { x: it.x + it.w, y: it.y + it.h }, color: it.data.color, width: it.data.width, highlight: it.type === 'highlight' });
                        ctx.restore();
                    }

                    // selection box and handles
                    if (selection && selection.pageIndex === idx && selection.id === it.id) {
                        ctx.strokeStyle = '#2563EB';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([4, 2]);
                        ctx.strokeRect(it.x, it.y, it.w, it.h);
                        ctx.setLineDash([]);
                        // handles are for hit-testing; visual only here
                    }
                });
            }

            function drawShape(ctx, shape) {
                const { kind, start, end, color, width, highlight } = shape;
                if (kind === 'rect') {
                    if (highlight) {
                        ctx.fillStyle = color;
                        ctx.globalAlpha *= 0.3;
                        ctx.fillRect(Math.min(start.x, end.x), Math.min(start.y, end.y), Math.abs(end.x - start.x), Math.abs(end.y - start.y));
                    } else {
                        ctx.strokeStyle = color; ctx.lineWidth = width;
                        ctx.strokeRect(Math.min(start.x, end.x), Math.min(start.y, end.y), Math.abs(end.x - start.x), Math.abs(end.y - start.y));
                    }
                } else if (kind === 'ellipse') {
                    const cx = (start.x + end.x) / 2; const cy = (start.y + end.y) / 2;
                    const rx = Math.abs(end.x - start.x) / 2; const ry = Math.abs(end.y - start.y) / 2;
                    ctx.beginPath();
                    ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
                    ctx.strokeStyle = color; ctx.lineWidth = width;
                    ctx.stroke();
                } else if (kind === 'arrow') {
                    const angle = Math.atan2(end.y - start.y, end.x - start.x);
                    ctx.strokeStyle = color; ctx.lineWidth = width; ctx.lineCap = 'round';
                    ctx.beginPath(); ctx.moveTo(start.x, start.y); ctx.lineTo(end.x, end.y); ctx.stroke();
                    const headLen = 10 + width * 2;
                    const hx1 = end.x - headLen * Math.cos(angle - Math.PI / 6);
                    const hy1 = end.y - headLen * Math.sin(angle - Math.PI / 6);
                    const hx2 = end.x - headLen * Math.cos(angle + Math.PI / 6);
                    const hy2 = end.y - headLen * Math.sin(angle + Math.PI / 6);
                    ctx.beginPath(); ctx.moveTo(end.x, end.y); ctx.lineTo(hx1, hy1); ctx.moveTo(end.x, end.y); ctx.lineTo(hx2, hy2); ctx.stroke();
                }
            }

            function shapePathToItem(sp) {
                const x = Math.min(sp.start.x, sp.end.x);
                const y = Math.min(sp.start.y, sp.end.y);
                const w = Math.abs(sp.end.x - sp.start.x);
                const h = Math.abs(sp.end.y - sp.start.y);
                return { id: crypto.randomUUID(), type: sp.kind === 'highlight' ? 'highlight' : sp.kind, x, y, w, h, data: { color: sp.color, width: sp.width, opacity: sp.opacity } };
            }

            function hitTestItem(idx, p) {
                const items = pageStates[idx].items;
                for (let i = items.length - 1; i >= 0; i--) {
                    const it = items[i];
                    if (p.x >= it.x && p.x <= it.x + it.w && p.y >= it.y && p.y <= it.y + it.h) {
                        return it; // could extend to detect corners
                    }
                }
                return null;
            }

            // expose redraw for outer scope
            window.redrawPage = redrawPage;
        }

        btnDownload.addEventListener('click', async () => {
            if (!pdfBytesOriginal) return;
            const pdfDoc = await PDFDocument.load(pdfBytesOriginal);
            const pages = pdfDoc.getPages();

            for (let i = 0; i < pages.length; i++) {
                const page = pages[i];
                const state = pageStates[i];
                const { width, height } = page.getSize();

                // scale factor between overlay and PDF page units
                const sx = width / state.width;
                const sy = height / state.height;

                // draw paths
                for (const path of state.paths) {
                    const scaledPoints = path.points.map(pt => ({ x: pt.x * sx, y: height - pt.y * sy }));
                    const shape = page.drawSvgPath(
                        'M ' + scaledPoints.map((pt, idx) => `${pt.x} ${pt.y}`).join(' L '),
                        { borderColor: hexToRgb(path.color, path.opacity ?? 1), borderWidth: path.width * ((sx + sy) / 2) }
                    );
                }

                // draw items
                for (const it of state.items) {
                    if (it.type === 'text') {
                        page.drawText(it.data.text, {
                            x: it.x * sx,
                            y: height - (it.y * sy) - (it.h * sy) + (it.data.size * sy * 0.2),
                            size: it.data.size * ((sx + sy) / 2),
                            color: hexToRgb(it.data.color, it.data.opacity ?? 1)
                        });
                    } else if (it.type === 'image') {
                        const imgBytes = await fetch(it.data.url).then(r => r.arrayBuffer());
                        let img;
                        try {
                            img = await pdfDoc.embedPng(imgBytes);
                        } catch {
                            img = await pdfDoc.embedJpg(imgBytes);
                        }
                        page.drawImage(img, {
                            x: it.x * sx,
                            y: height - (it.y * sy) - (it.h * sy),
                            width: it.w * sx,
                            height: it.h * sy,
                            opacity: it.data.opacity ?? 1
                        });
                    } else if (it.type === 'rect') {
                        page.drawRectangle({
                            x: it.x * sx,
                            y: height - (it.y * sy) - (it.h * sy),
                            width: it.w * sx,
                            height: it.h * sy,
                            borderColor: hexToRgb(it.data.color, it.data.opacity ?? 1),
                            borderWidth: it.data.width * ((sx + sy) / 2)
                        });
                    } else if (it.type === 'ellipse') {
                        page.drawEllipse({
                            x: (it.x + it.w / 2) * sx,
                            y: height - ((it.y + it.h / 2) * sy),
                            xScale: (it.w / 2) * sx,
                            yScale: (it.h / 2) * sy,
                            borderColor: hexToRgb(it.data.color, it.data.opacity ?? 1),
                            borderWidth: it.data.width * ((sx + sy) / 2)
                        });
                    } else if (it.type === 'arrow') {
                        const start = { x: it.x * sx, y: height - (it.y * sy) };
                        const end = { x: (it.x + it.w) * sx, y: height - ((it.y + it.h) * sy) };
                        page.drawLine({ start, end, color: hexToRgb(it.data.color, it.data.opacity ?? 1), thickness: it.data.width * ((sx + sy) / 2) });
                        // arrow head
                        const angle = Math.atan2(end.y - start.y, end.x - start.x);
                        const headLen = (10 + it.data.width * 2) * ((sx + sy) / 2);
                        const hx1 = { x: end.x - headLen * Math.cos(angle - Math.PI / 6), y: end.y - headLen * Math.sin(angle - Math.PI / 6) };
                        const hx2 = { x: end.x - headLen * Math.cos(angle + Math.PI / 6), y: end.y - headLen * Math.sin(angle + Math.PI / 6) };
                        page.drawLine({ start: end, end: hx1, color: hexToRgb(it.data.color, it.data.opacity ?? 1), thickness: it.data.width * ((sx + sy) / 2) });
                        page.drawLine({ start: end, end: hx2, color: hexToRgb(it.data.color, it.data.opacity ?? 1), thickness: it.data.width * ((sx + sy) / 2) });
                    } else if (it.type === 'highlight') {
                        page.drawRectangle({
                            x: it.x * sx,
                            y: height - (it.y * sy) - (it.h * sy),
                            width: it.w * sx,
                            height: it.h * sy,
                            color: hexToRgb(it.data.color, (it.data.opacity ?? 1) * 0.3)
                        });
                    }
                }
            }

            const bytes = await pdfDoc.save();
            const blob = new Blob([bytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'edited.pdf';
            document.body.appendChild(a); a.click(); document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });

        function hexToRgb(hex, opacity = 1) {
            const v = hex.replace('#', '');
            const r = parseInt(v.substring(0, 2), 16) / 255;
            const g = parseInt(v.substring(2, 4), 16) / 255;
            const b = parseInt(v.substring(4, 6), 16) / 255;
            return rgb(r, g, b, opacity);
        }

        function parseRange(input, max) {
            // e.g., "1-3,5,7-9"
            const parts = input.split(',');
            const pages = new Set();
            for (const part of parts) {
                const s = part.trim();
                if (!s) continue;
                if (s.includes('-')) {
                    const [a, b] = s.split('-').map(x => parseInt(x.trim(), 10));
                    if (Number.isNaN(a) || Number.isNaN(b)) throw new Error('Bad range');
                    const start = Math.min(a, b);
                    const end = Math.max(a, b);
                    for (let n = start; n <= end && n <= max; n++) pages.add(n);
                } else {
                    const n = parseInt(s, 10);
                    if (Number.isNaN(n)) throw new Error('Bad number');
                    if (n <= max) pages.add(n);
                }
            }
            if (pages.size === 0) throw new Error('Empty range');
            return Array.from(pages).sort((a, b) => a - b);
        }

        function downloadBlob(bytes, name) {
            const blob = new Blob([bytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = name; document.body.appendChild(a); a.click(); document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // z-order controls
        btnForward.addEventListener('click', () => {
            if (!selection) return;
            const items = pageStates[selection.pageIndex].items;
            const idx = items.findIndex(i => i.id === selection.id);
            if (idx >= 0 && idx < items.length - 1) {
                const [it] = items.splice(idx, 1);
                items.splice(idx + 1, 0, it);
                window.redrawPage(selection.pageIndex);
            }
        });
        btnBackward.addEventListener('click', () => {
            if (!selection) return;
            const items = pageStates[selection.pageIndex].items;
            const idx = items.findIndex(i => i.id === selection.id);
            if (idx > 0) {
                const [it] = items.splice(idx, 1);
                items.splice(idx - 1, 0, it);
                window.redrawPage(selection.pageIndex);
            }
        });

        // keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (!selection) return;
            const items = pageStates[selection.pageIndex].items;
            const idx = items.findIndex(i => i.id === selection.id);
            if (idx === -1) return;
            if (e.key === 'Delete') {
                const [removed] = items.splice(idx, 1);
                pushHistory({ type: 'delete-item', pageIndex: selection.pageIndex, item: removed });
                selection = null;
                window.redrawPage(selection ? selection.pageIndex : getCurrentViewportTopPageIndex());
            } else if ((e.ctrlKey || e.metaKey) && (e.key.toLowerCase() === 'd')) {
                const it = items[idx];
                const dup = JSON.parse(JSON.stringify(it));
                dup.id = crypto.randomUUID();
                dup.x += 10; dup.y += 10;
                items.splice(idx + 1, 0, dup);
                pushHistory({ type: 'add-item', pageIndex: selection.pageIndex, item: dup });
                selection = { pageIndex: selection.pageIndex, id: dup.id };
                window.redrawPage(selection.pageIndex);
                e.preventDefault();
            }
        });
    </script>
</body>
</html>


